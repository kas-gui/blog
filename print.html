<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>KAS blog</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Index</a></li><li class="chapter-item expanded "><a href="why-kas-text.html"><strong aria-hidden="true">2.</strong> Why KAS-text</a></li><li class="chapter-item expanded "><a href="line-wrapping.html"><strong aria-hidden="true">3.</strong> Line wrapping</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">KAS blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#kas-blog" id="kas-blog">KAS Blog</a></h1>
<p>Please see outline on the left.</p>
<h1><a class="header" href="#why-i-created-kas-text" id="why-i-created-kas-text">Why I created kas-text</a></h1>
<p>September 2020</p>
<h2><a class="header" href="#existing-libraries" id="existing-libraries">Existing libraries</a></h2>
<p>This is going to be a very brief (and fairly naive) dive into text rendering and
the state of available Rust libraries, written in easy English with minimal
jargon.</p>
<h3><a class="header" href="#the-basics" id="the-basics">The basics</a></h3>
<p>Lets see. You're writing a small graphical game/tool/general UI and wish to
print a simple string of text, say, &quot;Hello World!&quot; There are many APIs that can
do this, but still several steps involved:</p>
<ol>
<li>Selecting a font: this might be embedded or the app may try to discover a
&quot;standard&quot; system font. The <code>font-kit</code> crate can discover system fonts.</li>
<li>Reading the font: there are a selection of libraries available, from the
low level <code>ttf-parser</code> to the mid-level <code>ab_glyph</code> to more complex toolsets
including <code>font-kit</code>, <code>rusttype</code> and <code>fontdue</code>.</li>
<li>Translating the input string to a sequence of positioned and scaled glyphs
(<em>layout</em>): the above-mentioned <code>font-kit</code>, <code>rusttype</code> and <code>fontdue</code> can
all accomplish this, along with the more specialised <code>glyph_brush_layout</code>.</li>
<li>Rasterising glyphs: this is the job of <code>glyph_brush</code> and, again, <code>font-kit</code>,
<code>rusttype</code> and <code>fontdue</code>.</li>
<li>Integrating rasterisation with the graphics pipeline: e.g. <code>gfx_glyph</code> and
<code>wgpu_glyph</code> do this job. Several high-level libraries (e.g. <code>ggez</code> and
<code>amethyst_ui</code>) provide direct text support.</li>
</ol>
<p>Of course, mostly you only need consider steps 1 and 5 and you're done.</p>
<h3><a class="header" href="#wrapping-and-alignment" id="wrapping-and-alignment">Wrapping and alignment</a></h3>
<p>Above, we considered only a short line of text: &quot;Hello World!&quot; Frequently you
will have longer pieces of text that require <em>wrapping</em> (usually on word
boundaries), and you may wish the result to be <em>aligned</em> to the left, centre or
right, or even <em>justified</em>. Fortunately the above libraries already have you
covered (aside from justified text, which is less often supported).</p>
<p>Text wrapping is a deceptively simple problem, but more on that in my
<a href="line-wrapping.html">next post</a>.</p>
<h3><a class="header" href="#shaping" id="shaping">Shaping</a></h3>
<p>The above libraries all use a fairly simple layout system: match each <code>char</code> to
a font glyph, place this at the previous glyph's &quot;advance position&quot;, then if the
font provides kerning data for this pair of glyphs use it to adjust the gap
between the two. For English (and probably most languages) this is sufficient,
at least most of the time.</p>
<p><em>Shaping</em> allows more complex glyph selection and positioning, and is an
important part of <em>real</em> text libraries. See e.g.
<a href="https://harfbuzz.github.io/what-is-harfbuzz.html#what-is-text-shaping">HarfBuzz on shaping</a>
and
<a href="https://en.wikipedia.org/wiki/Complex_text_layout">Wikipedia on Complex Text Layout</a>
(although the latter also concerns bidirectional text; more on that later).</p>
<p>Essentially, shaping takes a text string along with a font and spits out a
sequence of positioned glyphs. This means that replacing the basic layout system
used above with a <em>text shaper</em> should, in theory, be straightforward.</p>
<p>For Rust, we have the HarfBuzz binding <code>harfbuzz-rs</code>, as well as two immature
pure-Rust libraries, <code>rustybuzz</code> and <code>allsorts</code>. Of the general-purpose text
libraries, only <code>fontdue</code> includes shaping in its roadmap.</p>
<h3><a class="header" href="#right-to-left-and-bidirectional-text" id="right-to-left-and-bidirectional-text">Right-to-left and bidirectional text</a></h3>
<p>Several scripts, such as Hebrew and Arabic, are written right-to-left.
Supporting such scripts generally also requires supporting embedded left-to-right
fragments, and thus requires supporting <em>bidirectional</em> texts.</p>
<p>Unicode, as part of <a href="https://www.unicode.org/reports/tr9/">TR9</a>, specifies how
to determine the <em>bidi embedding level</em> and thus the text direction for each
character in the source text, as well as how to re-order the input from logical
order into display order. Unfortunately, integrating support for bidi
texts into layout is not so simple (this is most of the topic of the
<a href="line-wrapping.html">next post</a>).</p>
<p>The <code>unicode-bidi</code> crate implements much of Unicode TR9, but on its own this
is insufficient. <em>None</em> of the above libraries support bidirectional text.</p>
<h3><a class="header" href="#formatting" id="formatting">Formatting</a></h3>
<p>Formatting may apply one of several effects to text. These include:</p>
<ul>
<li>adjusting the font size</li>
<li>changing the font's (foreground) colour</li>
<li>using a bold variant (or more generally, adjusting the weight)</li>
<li>using an italic variant (either via use of another font variant or via
slanting glyphs during rendering)</li>
<li>drawing underline or strikethrough</li>
</ul>
<p>Some of the above font libraries have limited support for formatting specified
via a list of text sections each with a font size and font identifier, and in
some cases also colour information. The user is expected to translate formatted
text from its source format as well as to select appropriate fonts.</p>
<h3><a class="header" href="#font-properties-and-variable-fonts" id="font-properties-and-variable-fonts">Font properties and variable fonts</a></h3>
<p>When mentioning font selection above, we glossed over a couple of issues. How
does one select an appropriate italic or bold variant? Can these be synthesised
if not provided?</p>
<p>The <code>font-kit</code> crate can help with the above: it allows font selection by family,
weight and style. Some fonts are <em>variable</em>, meaning that glyphs can be
synthesised to the required weight (giving much more control than simply &quot;bold&quot;
or &quot;normal&quot;). The style allows selection of normal, <em>italic</em> (curved) or
<em>oblique</em> (slanted) variants.</p>
<p>I have not investigated this topic, but it appears that only <code>font-kit</code>'s
rasteriser API supports selection of weight or style; all other Rust libraries
select font only by path/bytes and variant index (for multiple fonts embedded
in a font pack).</p>
<h3><a class="header" href="#font-fallbacks" id="font-fallbacks">Font fallbacks</a></h3>
<p>What if your chosen font doesn't include all required glyphs, e.g. if you choose
a font covering most European alphabets, but your user starts writing Korean?
I believe that no Rust libraries have even started trying to address this
problem.</p>
<p>The first sub-problem is an extension of font selection: choosing appropriate
fallback font(s). CSS allows the user direct control here: see
<a href="https://css-tricks.com/css-basics-fallback-font-stacks-robust-web-typography/">article</a>.
On Linux this is usually handled by Fontconfig.</p>
<p>The other sub-problem(s) concern integration: breaking text layout into multiple
runs should your shaper not support multiple fonts (as HarfBuzz doesn't), then
stitching the result back together.</p>
<h2><a class="header" href="#kas-text" id="kas-text">KAS-text</a></h2>
<p>The above libraries cover simple layout and rasterisation fairly well, but
also leave a lot out, especially regarding complex layout and use of formatted
input texts.</p>
<p>KAS-text attempts to fill this gap: translate from a raw input text to a
sequence of positioned glyphs, which can be easily adapted for use by
renderers such as <code>wgpu_glyph</code>. Additionally, it exposes a stateful
<code>prepared::Text</code> object, allowing fast re-draws and re-wrapping of a given
input text (though this stateful API may not be appropriate for all users).</p>
<p>Since this article is written after-the-fact,
<a href="https://github.com/kas-gui/kas-text/"><code>kas-text</code></a> v0.1 already exists. You can
read its <a href="https://docs.rs/kas-text/">API docs here</a>. v0.1 already supports
shaping (via HarfBuzz) and bidirectional text, which, to my knowledge, makes it
the first Rust library to support these features (on the full layout cycle from
raw text input to positioned glyphs), admittedly with imperfections.</p>
<p>Near-future plans include support for formatted text, including translation from
Markdown or (simple) HTML input and mostly-automatic font selection.
Other topics, such as vertical text, font synthesis, font fallbacks and
emoticons, have not been planned but could eventually be added.</p>
<h3><a class="header" href="#kas-gui" id="kas-gui">KAS GUI</a></h3>
<p>The v0.5 release of KAS has integration with KAS-text, including a reasonably
functional multi-line text-editor. <a href="https://github.com/kas-gui/kas/tree/master/kas-wgpu/examples#layout">Check it out</a> or run yourself:</p>
<pre><code class="language-sh">git clone https://github.com/kas-gui/kas.git
cd kas/kas-wgpu
cargo run --example layout --features shaping
</code></pre>
<h1><a class="header" href="#line-wrapping-the-hardest-problem-in-text-layout" id="line-wrapping-the-hardest-problem-in-text-layout">Line wrapping: the hardest problem in text layout?</a></h1>
<p>September 2020</p>
<p><em>Obviously</em> the title can't be true. Can it?</p>
<p>Unicode provides a <del>short</del> somewhat long <a href="https://www.unicode.org/reports/tr14/">technical report on line breaking</a>.
To quote from its overview:</p>
<blockquote>
<p>Line breaking, also known as word wrapping, is the process of breaking a section of text into lines such that it will fit in the available width of a page, window or other display area. The Unicode Line Breaking Algorithm performs part of this process. Given an input text, it produces a set of positions called &quot;break opportunities&quot; that are appropriate points to begin a new line. The selection of actual line break positions from the set of break opportunities is not covered by the Unicode Line Breaking Algorithm, but is in the domain of higher level software with knowledge of the available width and the display size of the text.</p>
</blockquote>
<p>To summarise, this algorithm tells us about mandatory breaks (e.g. after <code>\n</code>)
and optional breaks (roughly speaking, the start of each word).</p>
<p>Fortunately for us, the Unicode Line Breaking Algorithm has already been
implemented in Rust, by the <a href="https://docs.rs/xi-unicode/0.2.1/xi_unicode/"><code>xi-unicode</code></a>
library (from the same people as <a href="https://github.com/xi-editor/xi-editor">Xi Editor</a>
and <a href="https://github.com/linebender/druid">Druid</a>).</p>
<h2><a class="header" href="#one-foot-in-front-of-the-other" id="one-foot-in-front-of-the-other">One foot in front of the other</a></h2>
<p><img src="https://www.freetype.org/freetype2/docs/glyphs/metrics.png" alt="glyph metrics" /></p>
<p>Lets start with the basics: horizontal, left-to-right text with simple layout.
In this case, we use a <em>caret</em> starting at the line's origin. The first glyph is
placed on this caret, then the caret is advanced by the glyph's advance width.
The next glyph is placed similarly, except that if this pair of glyphs appears
in the font's <em>kerning table</em>, then an offset is applied (this allows e.g. the
'T' in 'To' to hang over the 'o').</p>
<p>Line wrapping such text is simple: whenever the caret position extends beyond
the available width, we back-step to the last optional line-break position, and
line-break there. Well, not quite: we allow whitespace to extend beyond the
line width (so if a bunch of extra spaces are inserted at the point a line is
wrapped, they don't actually add space anywhere).</p>
<p>The above is what the <code>glyph_brush_layout</code> crate (of
<a href="https://github.com/alexheretic/glyph-brush">glyph-brush</a>) does. It works fine
for most left-to-right languages, provided no complicated layout is needed.</p>
<p>Actually, there is another point missing from this story: hyphenation.
We leave this as a foot-note for now.</p>
<h2><a class="header" href="#shaping-1" id="shaping-1">Shaping</a></h2>
<p>Shaping was <a href="why-kas-text.html#shaping">discussed previously</a> and is an essential
part of complex text support: the above advance-and-apply-kerning rules are
insufficient for ligatures and entirely insufficient for complex texts like Arabic.
A <em>shaper</em> is a separate tool which, given a sequence of
(Unicode) text and a font, returns a list of positioned glyphs from this font.
One such shaper is <a href="https://harfbuzz.github.io/">HarfBuzz</a>.</p>
<p>Modifying our text layout system to support a shaper is not so hard (given a
suitable design). Integrating line wrapping with an external shaper is only a
little harder: the shaper returns a <em>single</em> line of text, within which we must
track the positions of optional line-breaks.</p>
<p>KAS-text implements support for both simple layout (directly) and complex layout
(via <a href="https://docs.rs/harfbuzz-rs">`harfbuzz-rs</a>) within its
<a href="https://github.com/kas-gui/kas-text/blob/master/src/shaper.rs">shaper module</a>.</p>
<h2><a class="header" href="#right-to-left-and-bi-directional-text" id="right-to-left-and-bi-directional-text">Right-to-left and bi-directional text</a></h2>
<p>This is where things start to get <em>fun</em>. When going left-to-right (hereafter
LTR), we only need to implement the caret position. When going RTL, if only we
could simply use the same logic but with flipped direction: alas, all font
glyphs are positioned <em>from the left</em>, so we have to typeset them <em>backwards</em>.</p>
<p>Worse, RTL texts may embed short sequences (such as numbers) or even quote
another language in the LTR direction — in some cases even embedding RTL text
within LTR within RTL. <a href="https://www.unicode.org/reports/tr9/">Unicode TR9</a>
specifies the <em>Basic Display Algorithm</em>, which essentially has three parts:</p>
<ol>
<li>Split the input text into paragraphs (trivial).</li>
<li>Resolve embedding levels, where levels run from 0 to 125 and odd levels
indicate RTL direction. This is complex but well specified and implemented
by libraries such as <a href="http://docs.rs/unicode-bidi">unicode-bidi</a> (albeit
with bugs).</li>
<li>Re-order the text. This is complex and inseperable from line-wrapping.</li>
</ol>
<p>To go into further detail, according to Unicode TR9, re-ordering text involves:</p>
<ol>
<li>Split the input text into <em>level runs</em>: maximal sub-sets of characters with
consistent embedding level.</li>
<li>For each level run, apply shaping to yield a glyph sequence.</li>
<li>Using the result of shaping, calculate line-wrapping positions.</li>
<li>For each line, apply a sequence of rules (L1-L4) to re-order
characters on that line.</li>
</ol>
<p>Unfortunately this leaves us a problem: we cannot resolve where lines start and
end without first applying shaping, and we but are given a set of rules to
re-order characters (i.e. Unicode code points) not glyphs. There are two ways
of, er, &quot;solving&quot;, this problem:</p>
<ol>
<li>Apply shaping, calculate line-break positions, re-order (at <code>char</code> level),
shape again. Not only does this require doing shaping twice, but further
there is no guarantee that the result of doing so will still fit within our
length bounds. Also, shapers like HarfBuzz expect text in <em>logical</em> order.</li>
<li>Transform the re-ordering logic to work with glyph sequences instead of
characters. HarfBuzz has implicit support for RTL text, so we never re-order
<em>characters</em>, but only <em>runs</em> and only then at embedding level 2 and higher.</li>
</ol>
<p>Option (2) is now the obvious choice, but there are still several details to
work out: line-wrapping both LTR and RTL text, correctly applying alignment,
embedding LTR within RTL and vice-versa, and a few corner cases. Each line has
a dominant (initial) direction (which may not be the same as the paragraph
direction). On that line one may append a whole run (in either direction) or
part of a wrapped line — but since the logical end of a line should not be in
its middle we only allow line wrapping when the run direction matches the line
direction. [This may need adjustment.]</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>As we have seen, line-wrapping is only a small problem within the scope of text
layout, but surprisingly complex in practice due to its inherent
inseperability from other aspects of text layout.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
